Here’s the plan: when someone uses a feature you don’t understand, simply shoot them.
-- Tim Peters

1. 

*args / **kwargs
*args 可以成批导入 arguments 变为 tuples
	  可以将 tuples 拆分 作为函数输入
**kwargs 可以将 key arguments 变成 dict
		 可以将 dict 拆分 作为函数输入
__repr__
当我们想所有环境下都统一显示的话，可以重构__repr__方法；当我们想在不同环境下支持不同的显示，例如终端用户显示使用__str__，而程序员在开发期间则使用底层的__repr__来显示，实际上__str__只是覆盖了__repr__以得到更友好的用户显示。__repr__是更好的选择。
__str__ "pretty print" 
if __str__ not defined, then __repr__ = __str__

__boo__
bool(x) 的背后是调用
x.__bool__() 的结果；如果不存在 __bool__ 方法，那么 bool(x) 会
尝试调用 x.__len__()。若返回 0，则 bool 会返回 False；否则返回
True。


列表推导
squared = [x**2 for x in range(10)] （这就是生成器的表达式）
如果生成其他类型如 tuple, array 等, 则需要引入 generator
# tuple(ord(symbol) for symbol in symbols)
一个个产出元素
# for car in ('{} {}'.format(brand, year) for brand in brands
										  for year in years)

tuple 元组
功能： 1. 记录数据 2. 不可变的list
- 元组拆包
path, filename = os.path.split('/home/file.exe')
- 用 * 可以进行 元组拆包 然后作为函数的参数 （__ 占位符）
- *args 获取不定数量的参数
- 元组拆包也可以用在嵌套结构中
- 构建简单类 最快最酷的方法 collections.namedtuple （具名元组）
	City = namedtuple('City', 'population name coordinates')
	- special methods:
		- _field: show all the methods as tuples (population, name, coordinates)
		- _make: create a new instance (same as City(*data))
		- _asdict: transfer the type to OrderedDict
- 不要把可变对象放到元组里面

切片 (list, tuple, str)
- 会ignore最后一个元素, l[1:2] 只返回位置1的元素
- my_list[a:b:c] 切片 以 c 为去区间 在a 和 b 之间
	my_list[::-1] 为reversed功能， 因为是从后往前切片
	Deck[12::13] 把每种花色的A挑出来
- 可以事先给 切片刀 起好名字！！
	- slice(a, b)
	>>> invoice = """
	... 0.....6................................40........52...55........
	... 1909 Pimoroni PiBrella $17.50 3 $52.50
	... 1489 6mm Tactile Switch x20 $4.95 2 $9.90
	... 1510 Panavise Jr. - PV-201 $28.00 1 $28.00
	... 1601 PiTFT Mini Kit 320x240 $34.95 1 $34.95
	... """
	>>> SKU = slice(0, 6)
	>>> DESCRIPTION = slice(6, 40)
	>>> UNIT_PRICE = slice(40, 52)
	>>> QUANTITY = slice(52, 55)
	>>> ITEM_TOTAL = slice(55, None)
	>>> line_items = invoice.split('\n')[2:]
	>>> for item in line_items:
	... print(item[UNIT_PRICE], item[DESCRIPTION])
	...
	$17.50 Pimoroni PiBrella
	$4.95 6mm Tactile Switch x20
	$28.00 Panavise Jr. - PV-201
	$34.95 PiTFT Mini Kit 320x240


-多维切片
	np.ndarray[a:b, m:n]

- ellipsis 省略... (其实他是一个对象)
	x[i, ...] 等于 x[i, :, :, :] (多维切片)
	f(a, ... , z) （参数省略）

- 切片赋值
	>>> l
	[0, 1, 20, 30, 5, 6, 7, 8, 9]
	>>> del l[5:7]
	>>> l
	[0, 1, 20, 30, 5, 8, 9]
	>>> l[3::2] = [11, 22]
	>>> l
	[0, 1, 20, 11, 5, 22, 9]
	>>> l[2:5] = 100 ➊
	Traceback (most recent call last):
	File "<stdin>", line 1, in <module>
	TypeError: can only assign an iterable
	>>> l[2:5] = [100]
	>>> l
	[0, 1, 100, 22, 9]

- + / * 
	都遵循这个规律，不修改原有的操作对象，而是构建一个全新的
	序列。
	- 快速创建嵌套列表
		>>> board = [['_'] * 3 for i in range(3)] ➊
		>>> board
		[['_', '_', '_'], ['_', '_', '_'], ['_', '_', '_']]
		>>> board[1][2] = 'X' ➋
		>>> board
		[['_', '_', '_'], ['_', '_', 'X'], ['_', '_', '_']]

- += / *= (__iadd__) (__imul__)
	+= / *= 等于 a = a + b / a = a*b
	- 可变序列，只记录原对象 a ， 效率很高。 不可变序列， 产生了新的对象， 效率很低。 尽量不要用在 不可变序列上。
	- 但 str 是个例外，Cpython 会提前分配多余的空间进行增量操作

- sort / sorted (内置算法为 timsort)
	sort (return None, replace the original list)
	sorted (return new list, doesn't chage orignial list)
	参数 reverse : 升序降序
	参数 key : key=len 按长度排序
		 	   key=str.lower 忽略大小写 等等
		 	   key=int
		 	   （按照什么来排序）

- bisect （二分法搜索）
	- generally useful for categorizing numeric data

	>>> def grade(score, breakpoints=[60, 70, 80, 90], grades='FDCBA'):
	... i = bisect.bisect(breakpoints, score)
	... return grades[i]
	...
	>>> [grade(score) for score in [33, 99, 77, 70, 89, 90, 100]]
	['F', 'A', 'C', 'C', 'B', 'A', 'A']

	- 有序列表中插入数据，且不打乱顺序！
	bisect.insort(my_list, new_item)


替代list的一些最优数据结构
- 检查一个元素是否出现在一个集合中的操作频率很高 用 set
- 只包含数字的列表 用 array (支持所有可变序列的操作)
	- 创建 array 需要 一个 类型码， 例如 'd' 告诉计算机为浮点数组
	- 快速 存/读 .tofile/.fromfile (二进制读存快6-7倍)
	- 另一种快速读写方法则为 pickle
	- array 不支持 sort() 但支持 sorted() 重新创建数组
	- memoryview CAN'T UNDERSTAND!
	- 处理数据还是用numpy/panda吧！
- 双向队列
	- collections.deque 两端添加或删除元素
	- 可以设置 maxlen 来存放 “最近用到的几个元素”
		如果超过maxlen: append 会挤掉左边元素
						appendleft 会挤掉右边元素
	- deque.rotate(n): n > 0, 最右边 n 个元素移到最左边
					   n < 0, 最左边 n 个元素移到最右边
	- deque.extend(list) / deque.extendleft(list) 直接插入多项数据
	- deque.popleft / deque.append


Dict/Set
- different ways to init a Dict:
	>>> a = dict(one=1, two=2, three=3)
	>>> b = {'one': 1, 'two': 2, 'three': 3}
	>>> c = dict(zip(['one', 'two', 'three'], [1, 2, 3]))
	True
- 字典推导
	>>> DIAL_CODES = [ ➊
	... (86, 'China'),
	... (91, 'India'),
	... (1, 'United States'),
	... (62, 'Indonesia'),
	... (55, 'Brazil'),
	... (92, 'Pakistan'),
	... (880, 'Bangladesh'),
	... (234, 'Nigeria'),
	... (7, 'Russia'),
	... (81, 'Japan'),
	... ]
	>>> country_code = {country: code for code, country in DIAL_CODES} ➋
	>>> country_code
	{'China': 86, 'India': 91, 'Bangladesh': 880, 'United States': 1,
	'Pakistan': 92, 'Japan': 81, 'Russia': 7, 'Brazil': 55, 'Nigeria':
	234, 'Indonesia': 62}
	>>> {code: country.upper() for country, code in country_code.items() ➌
	... if code < 66}
	{1: 'UNITED STATES', 55: 'BRAZIL', 62: 'INDONESIA', 7: 'RUSSIA'}

（暂过）

- 6.文本
(暂过)


- 7.函数装饰器和闭包
- 装饰器其实就是一个以函数作为参数并返回一个替换函数的可执行函数。
- 1. 装饰器的一大特性是，能把被装饰的函数替换成具有新功能的其他函数。
- 2. 第二个特性是，装饰器在加载模块时立即执行。
- 在 python 中 一切都是对象， 包括函数
- @ 有个很Q的名字叫 语法糖
- 一个很cool 的结构 (__call__)
  函数被唤醒的时候，干什么事情

	class Average():
		def __init__(self):
			self.series = []

		def __call__(self, new_value):
			self.series.append(new_value):
			total = sum(self.series)
			return total/len(self.sereis)
	avg = Average()

	另一种实现

	def Average():
		### 闭包开始 ###
		series = []

		def avg(new_value):
			series.append(new_value)
			total = sum(series)
			return total/len(series)
		return avg
		### 闭包结束 ###
		series 在这里是 free variable
		会被绑定到 avg 里面

		综上，闭包是一种函数，它会保留定义函数时存在的自由变量的绑定，
		这样调用函数时，虽然定义作用域不可用了，但是仍能使用那些绑定。

		注意，因为 series 是可变类型 所以可以作为 free variable
		但是如果是 int/str/tuple 不可变类型，就不能更新，更新的时候会被变成 local variable
		
		解决办法为 声明 nonlocal 如下

		def make_averager():
			count = 0
			total = 0
				def averager(new_value):
					nonlocal count, total
					count += 1
					total += new_value
					return total / count
			return averager

- Python 内置三个 decorator
	@property / @classmethod / @staticmethod
	@property is to make property variable an easy way to get/set
	read/write property: @property + @property.setter
	read only property: @property (no way to set new value)

- 常用的 functools 中的 decorator
1. lru_cache()
	优化重复调用相同变量，给函数"记忆"。
	参数：maxsize=128 : 缓存多少个变量
		  typed=True : 则把不同数据类型分开保存

2. singledispatch (dispatch 派遣)
（略过）



8.对象
- Python 中的变量本质上是 引用式变量 (b refer to a)
>>> a = [1, 2, 3]
>>> b = a
>>> a.append(4)
>>> b
[1, 2, 3, 4]

- Python 中的赋值 “=”，一定是先读右边， 然后再把左边的变量 贴上去

- 是否 “x is y” 在于 比较 id(), 就是对象的内存地址
- 而 == 只是比较值
- 注意，在 变量和单值 比较，最好用 is 例如 x is None. 因为 is 运算符比 == 速度快

- tuple 很特殊， 本身结构是不可变的 但是里面的元素可以变。因为他们里面的数据都是引用。
- 而 str, araray 等是连同内存中保存的数据一起保存


- x._property means "private"
	A public member can be accessed from outside the class, which for practical considerations means "potentially anywhere". If something goes wrong with a public field, the culprit can be anywhere, and so in order to track down the bug, you may have to look at quite a lot of code.

	A private member, by contrast, can only be accessed from inside the same class, so if something goes wrong with that, there is usually only one source file to look at. If you have a million lines of code in your project, but your classes are kept small, this can reduce your bug tracking effort by a factor of 1000.

	So, as to when you should make things private: I'd say make everything private by default, and then expose only those parts that absolutely have to be public. The more you can make private, the better.

- 浅复制 copy_list = list(original_list)
	The problem is that the elements of two lists (copyied/original) may (list) or may not (tuples) refer to the same object. Sometimes it's not what we want.
- copy.copy() (will refer to the same id objects)
- copy.deepcopy() (will not ~~~~)

- Call By Sharing (Only way for the python to passing variable)
- Warning: don't use changeable variable (i.e. list) as the default value for function.

- del 垃圾回收
	“当对象的引用数量归零以后，垃圾回收才会销毁对象”
(后面没懂)

- 弱引用
（pass）

9. 符合python风格的对象
"never use double underline!"
@classmethod
一个只在类中运行而不在实例中运行的方法
when this method is called, we pass the class as the first argument instead of the instance of that class (as we normally do with methods). This means you can use the class and its properties inside that method rather than a particular instance.

@staticmethod means: when this method is called, we don't pass an instance of the class to it (as we normally do with methods). This means you can put a function inside a class but you can't access the instance of that class (this is useful when your method does not use the instance).

